---
title: "Phase0_1"
author: "Xinnuo Chen"
date: "2025-04-03"
output: html_document
---
Base de dades amb dues variables, pes i alçada, 120 observacions. 
Es prova d'aconseguir un rang més variat d'SPECKS mitjançant l'ajust del cp.values i del minbucket.values.

# Llibreries
```{r}
# install.packages("synthpop")
library(synthpop)

# install.packages("NbClust")
library(NbClust)

library(ggplot2)
library(factoextra)

# install.packages("DescTools") #index de Gini
library(DescTools)

library(cluster) #index de Silhouette

# install.packages("label.switching")
library(label.switching)

library(car) #scatterplot

library(tidyverse)

library(clue) #label switching

library(caret) #calcular accuracy

library(rpart)

library(dgof)

library(dplyr)
library(tibble)

# install.packages("paletteer")
# install.packages("scales")
library(paletteer)
library(scales)
colour.patteer <- paletteer_c("ggthemes::Classic Orange-Blue", 80)
colours <- colour.patteer[c(23, 78, 43)]

library(tidyr)     # pivot_longer
```


# Functions
```{r}
# Real data generation
twovar.data.generation <- function(N, mean, sd, varname=c("height","weight", "group"),groupseed=123){
# mean1 dataframe de mitjana para cada grup i cada variable. columna-variable, fila-grup
  # groupnumber es nombre de cluster dins d'una base de dades
  groupnumber <- nrow(mean)
  n <- N/groupnumber # nombre d'obervacions per cluster
  
  # Comprovació
   if(nrow(mean) != nrow(sd)) {
     stop("The number of parameters does not match the number of groups.")
   }
  # comprovar que el nombre de parametres es correcte d'acord als grups que es vol crear
  
  # Generació de les dades
  set.seed(groupseed)
  var1 <- c()
  var2 <- c()
  for(i in 1:groupnumber){ #per cada base grup
    var1.group <- rnorm(n, mean = mean[i,1], sd = sd[i,1]) #fila grup, col variable
    var2.group <- rnorm(n, mean = mean[i,2], sd = sd[i,2])
     
    var1 <- c(var1, var1.group)
    var2 <- c(var2, var2.group)
  }
  
  group <- rep(1:groupnumber, each=n)
  data <- data.frame(var1, var2, group)
  colnames(data) <- varname
  return(data)
}


synt.data.generation <- function(real.data, cp.values, minbucket.values, m){
  
  specks.value <- data.frame(cp = numeric(0), minbucket = numeric(0), SPECKS = numeric(0))
  # sds.default <- list() # list on guardo els objectes syn
  synt.data <- list() # list on guardo totes les dades sintetiques generades
  
  for(i in 1:length(cp.values)){
    for(j in 1:length(minbucket.values)){
      syn.obj <- syn(real.data,  # Generació amb CART
                     method = rep("cart", ncol(real.data)),
                     cart.control = list(cp = cp.values[i], minbucket = minbucket.values[j]),
                     m = m,
                     print.flag = FALSE)
     # syn.obj <- as.list(syn.obj)
     # sds.default <- c(sds.default, syn.obj)
      synt.data <- c(synt.data, syn.obj$syn)
      
      for(k in 1:m){
        names(synt.data[[k]]) <- names(real.data)
        
        data <- rbind(
          cbind(real.data, label = 0),
          cbind(synt.data[[k]], label = 1)
        )
        
        # Calcular SPECKS para la combinación actual de cp y minbucket
        specks.val <- specks(data = data)$Specks
        specks.value <- rbind(specks.value, data.frame(minbucket = minbucket.values[j], cp = cp.values[i], SPECKS = specks.val))
      }
    }
  }  
  results <- list("Specks" = specks.value, "Syn data" = synt.data)
  return(results)
}

# K decision & clustering 
k.decision <- function(data, k.real = 0, synthetic = TRUE){
  if(synthetic == FALSE){
    kopt.obj <- NbClust(data = data, diss = NULL, distance = "euclidean", method = "kmeans", index = "all", alphaBeale = 0.1)
    kopt <- as.numeric(names(table(as.vector(kopt.obj$Best.nc[1,])))[which.max(table(as.vector(kopt.obj$Best.nc[1,])))])
    sdata <- scale(data)
    clust <- kmeans(sdata, kopt, nstart = 25)
    
    clustering.result <- list("K optim" = kopt, "Clustering" = clust)
    return(clustering.result)
  } else {
    kopt.obj <- NbClust(data = data, diss = NULL, distance = "euclidean", method = "kmeans", index = "all", alphaBeale = 0.1)
    kopt <- as.numeric(names(table(as.vector(kopt.obj$Best.nc[1,])))[which.max(table(as.vector(kopt.obj$Best.nc[1,])))])
    
    if(kopt == k.real){
      sdata <- scale(data)
      clust <- kmeans(sdata, kopt, nstart = 25) #resultado de clustering
      
      clustering.result <- list("K optim" = kopt, "Clustering" = clust)
      return(clustering.result)
    }
  }
}


# SPECKS CALCULATION
specks <- function(data, sample=FALSE, minbucket=5, cp = 1e-3){   #### With pvalue
  
  if(sample==TRUE){
    data[,3] <- sample(data[,3])
  }
  
  cart_model <- rpart(
    formula = label ~ .,             # label com a resposta, la resta com a predictors
    data = data,
    method = "class",                # arbre de classificació
    control = rpart.control(mincriterion = 0, 
                            minbucket = minbucket, 
                            cp = cp))
  
  pred.prob <- predict(cart_model, type = "prob")[, 2]
  
  label.vector <- data$label
  
  prop.score.real  <- pred.prob[label.vector == 0]
  prop.score.synt  <- pred.prob[label.vector == 1]
  
  ecdf.real  <- ecdf(prop.score.real)
  ecdf.synth <- ecdf(prop.score.synt)
  
  all.scores <- sort(unique(c(prop.score.real, prop.score.synt)))
  
  specks.value <- max(abs(ecdf.real(all.scores) - ecdf.synth(all.scores)))
  p.value <- suppressWarnings(ks.test(prop.score.real, prop.score.synt)$p)
  
  return(data.frame(
    "Specks" = specks.value, 
    "P-value" = p.value))
}

# Label switching function
label.switching <- function(km.real, km.synt){
  if(!is.null(km.synt)){
      centroids <- rbind(km.real$centers, km.synt$centers)
      dist.global <- as.matrix(dist(centroids, method = "euclidean"))
      n.real <- nrow(km.real$centers) #numero de cluster en real
      n.synt <- nrow(km.synt$centers) #numero de cluster en synt
      dist <- dist.global[1:n.real, (n.real + 1) : (n.real + n.synt)]
      label.ass <- solve_LSAP(dist, maximum = FALSE) 
      
      # Reetiquetació els clústers sintètics
      km.synt$recluster <- km.real$cluster # nova variable
      
      for (i in 1:length(label.ass)) {
        km.synt$recluster[km.synt$cluster == label.ass[i]] <- i
      }
  }
  return(km.synt)
}

# Metrics function
cluster.metrics <- function(km.real, km.synt, k.real, k.synt, real.data, synt.data){
    # Nombre de cluster
    clust.num <- k.synt/k.real
    
    # Nombre d'observacions dins de clúster -> accuracy
    conf.mat <- confusionMatrix(data = as.factor(km.synt$recluster), reference = as.factor(km.real$cluster))
    accuracy <- conf.mat$overall["Accuracy"]
    
    # Distribució d'observacions en clúster -> Índex de Gini
    gini.real <- Gini(km.real$size)
    gini.synt <- Gini(km.synt$size)
    gini <- gini.synt/gini.real
    
    # Distancia d'observacions a cluster -> Coeficient de silhouette (entre -1 i 1)
    sil.real <- mean(silhouette(km.real$cluster, dist(real.data))[,3])
    sil.synt <- mean(silhouette(km.synt$recluster, dist(synt.data))[,3])
    sil <- sil.synt/sil.real
    
    # Distancia mitjana entre centroides
    lreal.data <- real.data
    lreal.data$label <- as.factor(km.real$cluster)
    lsynt.data <- synt.data
    lsynt.data$label <- as.factor(km.synt$recluster)

    real.centroid <- aggregate(cbind(height, weight) ~ label,
                                data = lreal.data,
                                FUN = base::mean)
    synt.centroid <- aggregate(cbind(height, weight) ~ label,
                                data = lsynt.data,
                                FUN = base::mean)
    real.centroid <- real.centroid[order(real.centroid$label), ]
    synt.centroid <- synt.centroid[order(synt.centroid$label), ]
    distances <- sqrt(
      (real.centroid$height - synt.centroid$height)^2 + 
      (real.centroid$weight - synt.centroid$weight)^2
    )
    mean.distance <- mean(distances)

    # Variancia mitjana entre centroides
    real.var <- aggregate(cbind(height, weight) ~ label,
                                data = lreal.data,
                                FUN = var)
    synt.var <- aggregate(cbind(height, weight) ~ label,
                                     data = lsynt.data,
                                     FUN = var)
    real.var <- real.var[order(real.var$label), ]
    synt.var <- synt.var[order(synt.var$label), ]
    real.var <- real.var[,-1]
    synt.var <- synt.var[,-1]
    
    dif.var <- abs(real.var - synt.var)
    mean.var <- mean(unlist(dif.var))
    
  result <- list("Clus.num" = clust.num, "Accuracy" = accuracy, "Gini" = gini, "Sil" = sil, "Mean distance" = mean.distance, "Mean variance" = mean.var)
  return(result)
}

plot.metrics <- function(df, specks.col = "SPECKS") {
  num_cols <- sapply(df, is.numeric)
  num_cols[specks.col] <- FALSE

  long.df <- pivot_longer(df,
                          cols      = names(num_cols)[num_cols],
                          names_to  = "Metric",
                          values_to = "Value")

  ggplot(long.df,
         aes(x = .data[[specks.col]], y = Value)) +   # tidy eval
    geom_point(alpha = 0.6) +
    geom_smooth(method = "lm", se = FALSE, colour = "red", formula = y ~ x) +
    facet_wrap(~ Metric, scales = "free_y") +
    labs(x = specks.col, y = NULL,
         title = "Relació de cada mètrica amb SPECKS") +
    theme_minimal()
}
```


# Generació de dades reals
```{r}
my.seed <- 12345
set.seed(my.seed)
mean <- data.frame(h=c(165,185),w=c(55,75))
sd <- data.frame(h=c(10,10), w=c(5,5))

real.data <- twovar.data.generation(120, mean=mean, sd=sd, groupseed = my.seed)
plot(real.data$height, real.data$weight, main = "Real data", xlab = "HEIGHT", ylab = "WEIGHT", col = real.data$group, pch = 19)
```


# Generació de dades sintètiques
```{r}
real.data <- real.data[,-3]
cp.values <- c(0.0001, 0.001, 0.01, 0.03, 0.05, 0.1)
minbucket.values <- c(1, 3, 5, 10, 20, 30, 60, 120)

synt.data.obj <- synt.data.generation (real.data, cp.values, minbucket.values, m=10)
specksa <- synt.data.obj$Specks$SPECKS #vector amb el specks de tots els datasets sintetics generats
synt.data <- synt.data.obj$`Syn data` #vector amb els objectes de tots els datasets sintetics generats
```


# K optim i Clustering i Label switching
```{r}
k.real <- k.decision(real.data, synthetic = FALSE)$`K optim` #k optim del dataset real
km.real <- k.decision(real.data, synthetic = FALSE)$Clustering 

result <- lapply(synt.data, function(df){
            k.decision(df, k.real = k.real, synthetic = TRUE)
          })
k.synt <- as.vector(lapply(result, function(res) res[["K optim"]])) #k optim del dataset sintetic
km.synt <- lapply(result, function(res) res[["Clustering"]])

ls.km.synt <- lapply(km.synt, function(ls) label.switching(km.real, ls))
```

# Metrics
```{r}
save(km.real, km.synt, ls.km.synt, k.real, k.synt, real.data, synt.data, specksa, file = "Objetctv0_1.RData")
load("Objetctv0_1.RData")

clust.num <- numeric()
accuracy <- numeric()
gini <- numeric()
sil <- numeric()
mean.distance <- numeric()
mean.var <- numeric()
for(i in 1:length(ls.km.synt)){
  if(length(k.real) == 1 &&
     !is.null(k.synt[[i]]) &&
     length(k.synt[[i]]) == 1)
  {
    if(k.real == k.synt[[i]]){
      result <- cluster.metrics(km.real, km.synt = ls.km.synt[[i]], k.real=k.real, k.synt = k.synt[[i]], real.data=real.data, synt.data = synt.data[[i]])
      clust.num <- c(clust.num, result$Clus.num)
      accuracy <- c(accuracy, result$Accuracy)
      gini <- c(gini, result$Gini)
      sil <- c(sil, result$Sil)
      mean.distance <- c(mean.distance, result$`Mean distance`)
      mean.var <- c(mean.var, result$`Mean variance`)
    }
  }
}

metrics <- data.frame("Clus.num" = clust.num, "Accuracy" = accuracy, "Gini" = gini, "Sil" = sil, "Mean distance" = mean.distance, "Mean variance" = mean.var)

which.null <- vapply(k.synt, is.null, logical(1))
specksa.2 <- specksa[!which.null]

metrics$SPECKS <- specksa.2

```

# Graphics
```{r}
plot.metrics(metrics)
```


