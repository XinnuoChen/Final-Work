---
title: "SPECKS_DISTRIBUTION"
author: "Xinnuo Chen"
date: "2025-04-01"
output: html_document
---

### Llibreries
```{r}
# install.packages("synthpop")
library(synthpop)

# install.packages("NbClust")
library(NbClust)

library(ggplot2)
library(factoextra)

# install.packages("DescTools") #index de Gini
library(DescTools)

library(cluster) #index de Silhouette

# install.packages("label.switching")
library(label.switching)

library(car) #scatterplot

library(tidyverse)

library(clue) #label switching

library(caret) #calcular accuracy

library(rpart)

library(dgof)

library(dplyr)
library(tibble)

# install.packages("paletteer")
# install.packages("scales")
library(paletteer)
library(scales)
colour.patteer <- paletteer_c("ggthemes::Classic Orange-Blue", 80)
colours <- colour.patteer[c(23, 78, 43)]

library(tidyr)     # pivot_longer
library(mvtnorm)
```

### Funcions
```{r}
normal.data.generation <- function(n, mu, sigma = NULL, seed = NULL)
{
  if(!is.null(seed)) set.seed(seed)
  
  # Si no passes cap matriu, fem una de correlacions AR(1) (rho = 0.4)
  if(is.null(sigma)){
    rho   <- 0.4
    idx   <- 0:(length(mu)-1)
    sigma <- outer(idx, idx, function(i, j) rho^abs(i - j))  # AR(1)
  }
  
  stopifnot(all(dim(sigma) == c(length(mu), length(mu))),
            isSymmetric(sigma),
            all(eigen(sigma, only.values = TRUE)$values > 0))  # ha de ser definida positiva
  
  mat <- rmvnorm(n, mean = mu, sigma = sigma)
  as.data.frame(mat)
}
```

# 1st scenari: Generació amb model cart i càlcul de l'specks amb model de classificació CART.
Resultat: El model es capaç d'identificar les observacions sintètiques amb una probabilitat més alta de ser sintètica, i els reals amb una probabilitat més baixa de ser sintètica, de forma que el SPECKS obtingut resulta ser un valor bastant elevat portant al rebuig de la hipòtesi nul·la de la igualtat del dataset real i sintètica. 

```{r}
#### Data generation ####
my.seed <- 12345
set.seed(my.seed)
mu1 <- c(160, 50, 20, 7, 6, 8, 5, 8)
mu2 <- c(180, 65, 24, 5, 7, 8, 9, 6)

df1 <- normal.data.generation(n=250, mu=mu1)
df2 <- normal.data.generation(n=250, mu=mu2)

real.data.1 <- rbind(df1, df2)

sds.default.cart1 <- syn(real.data.1, method = "cart", seed = my.seed, m = 1, print.flag = FALSE, )
synt.data.cart1 <- sds.default.cart1$syn


#### SPECKS synthpop ####
utilityGen.cart1 <- utility.gen(sds.default.cart1, real.data.1, method = "cart", print.flag = FALSE)
specks.cart1.synthpop <- utilityGen.cart1$SPECKS


#### SPECKS manual ####
combined.data.cart1 <- rbind(
  cbind(real.data.1, label = 0), # Original data (label = 0)
  cbind(synt.data.cart1, label = 1) # Synthetic data (label = 1)
)

cart_model1 <- rpart(
  formula = label ~ .,             # label com a resposta, la resta com a predictors
  data = combined.data.cart1,
  method = "class",                # arbre de classificació
  control = rpart.control(mincriterion = 0, 
            minbucket = 5, 
            cp = 1e-3))

pred.prob.cart1 <- predict(cart_model1, type="prob")[,2]
  
  label_vector.cart1 <- combined.data.cart1$label
  
  prop.score.real.cart1  <- pred.prob.cart1[label_vector.cart1 == 0]
  prop.score.synt.cart1  <- pred.prob.cart1[label_vector.cart1 == 1]

  ecdf.real.cart1  <- ecdf(prop.score.real.cart1)
  ecdf.synth.cart1 <- ecdf(prop.score.synt.cart1)

  all.scores.cart1 <- sort(unique(c(prop.score.real.cart1, prop.score.synt.cart1)))

  specks.manual.cart1 <- max(abs(ecdf.real.cart1(all.scores.cart1) - ecdf.synth.cart1(all.scores.cart1)))

#### KOLMOGOROV-SMIRNOV ####
ks.test(prop.score.real.cart1, prop.score.synt.cart1)
```


## SPECKS's distribution simulation
```{r}
specks.sim <- function(real, synt){
  ecdf.real <- ecdf(real)
  ecdf.synt <- ecdf(synt)
  
  all <- sort(unique(c(real, synt)))
  specks.value <- max(abs(ecdf.real(all) - ecdf.synt(all)))
  return(specks.value)
}

prop.scores.cart1 <- c(prop.score.real.cart1, prop.score.synt.cart1)

n.real.cart1 <- length(prop.score.real.cart1) 
n.synt.cart1 <- length(prop.score.synt.cart1)
n.cart1 <- c(n.real.cart1, n.synt.cart1)
N.cart1 <- n.real.cart1+n.synt.cart1
nperms <- 9999

specks.perms.cart1 <- replicate(nperms, {
  idx.cart1 <- sample(1:N.cart1, n.real.cart1)
  real.cart1 <- prop.scores.cart1[idx.cart1]
  synt.cart1 <- prop.scores.cart1[-idx.cart1]
  
  specks.sim(real.cart1, synt.cart1)
})

specks.distribution.cart1 <- ggplot(data.frame(Specks = specks.perms.cart1), aes(x=Specks)) + 
  geom_histogram(binwidth=0.01) +
  geom_vline(aes(xintercept = specks.manual.cart1, color = "Valor d'Specks"), 
             linetype = "dashed", size = 1) +
  scale_color_manual(name = "Leyenda", values = c("Valor d'Specks" = "red"))

comptador.cart1 <- sum(specks.perms.cart1 >= specks.manual.cart1)
pvalor.cart1 <- (comptador.cart1+1)/(nperms+1)
pvalor.cart1

```


## Distribución de densidad de los propensity scores
```{r}
# Estimació suavitzada de la densitat a partir dels valors prop.score.real:
dens.prop.score.real.cart1= density(prop.score.real.cart1)
plot(dens.prop.score.real.cart1, col="green", main= "Estimació suavitzada scores", sub="(Gaussian Kernel)", ylim=c(0,10))
rang.x = seq(from = -0.1, to = 1, by = 0.1)
# La dibuixem superposada a les prop.score.synt, en vermell:
dens.prop.score.synt.cart1 = density(prop.score.synt.cart1)
lines(dens.prop.score.synt.cart1, col="red")
abline(v = mean(prop.score.synt.cart1), col = "red", lwd = 2, lty = 2)
abline(v = mean(prop.score.real.cart1), col = "green", lwd = 2, lty = 2)
legend("topleft", legend=c("real", "synt"),  
       fill = c("green","red")) 
```

## Distribución acumulada de los propensity scores
```{r}
library(dplyr)

ecdf_real.cart1 <- ecdf(prop.score.real.cart1)
ecdf_synt.cart1 <- ecdf(prop.score.synt.cart1)

# Crear una cuadrícula de valores de propensity score a partir de los valores únicos (y ordenados)
grid_prop.cart1 <- sort(unique(c(prop.score.real.cart1, prop.score.synt.cart1)))

# Calcular la probabilidad acumulada para cada valor de propensity score en la cuadrícula
prob_acumulada_ecdf_real.cart1 <- ecdf_real.cart1(v = grid_prop.cart1)
prob_acumulada_ecdf_synt.cart1 <- ecdf_synt.cart1(v = grid_prop.cart1)

# Unir los valores calculados en un dataframe
df_ecdf.cart1 <- data.frame(
  propensity_score.cart1 = grid_prop.cart1,
  ecdf_real.cart1 = prob_acumulada_ecdf_real.cart1,
  ecdf_synt.cart1 = prob_acumulada_ecdf_synt.cart1
) %>%
  pivot_longer(
    cols = c(ecdf_real.cart1, ecdf_synt.cart1),
    names_to = "data_type",
    values_to = "ecdf"
  )


# Graficar la función de distribución acumulada empírica de los propensity scores
grafico_ecdf.cart1 <- ggplot(data = df_ecdf.cart1, 
                       aes(x = propensity_score.cart1, y = ecdf, color = data_type)) +
  geom_line(size = 0.5) +
  scale_color_manual(values = c("green", "red"), labels = c("Real", "Sintético")) +
  labs(
    title = "Distribución acumulada de Propensity Scores",
    subtitle = "Comparación entre datos reales y sintéticos",
    color = "Tipo",
    x = "Propensity Score",
    y = "Probabilidad acumulada"
  ) +
  theme_bw() +
  theme(legend.position = "bottom",
        plot.title = element_text(size = 12))

# Mostrar el gráfico
grafico_ecdf.cart1
```

# 2nd scenari: Generació amb model cart i càlcul de l'specks amb model LOGIT.
Resultat: El model logit no es capaç d'identificar les observacions que provenen del dataset sintètic o real. Aleshores el resultat d'SPECKS es bo. 
```{r}
#### Data generation ####
my.seed <- 12345
set.seed(my.seed)
mu1 <- c(160, 50, 20, 7, 6, 8, 5, 8)
mu2 <- c(180, 65, 24, 5, 7, 8, 9, 6)

df1 <- normal.data.generation(n=250, mu=mu1)
df2 <- normal.data.generation(n=250, mu=mu2)

real.data.1 <- rbind(df1, df2)

sds.default.cartlogit <- syn(real.data.1, method = "cart", seed = my.seed, m = 1, print.flag = FALSE, )
synt.data.cartlogit <- sds.default.cartlogit$syn


#### SPECKS synthpop ####
utilityGen.cartlogit <- utility.gen(sds.default.cart1, real.data.1, method = "logit", print.flag = FALSE)
specks.cartlogit.synthpop <- utilityGen.cartlogit$SPECKS


#### SPECKS manual ####
combined.data.cartlogit <- rbind(
  cbind(real.data.1, label = 0), # Original data (label = 0)
  cbind(synt.data.cartlogit, label = 1) # Synthetic data (label = 1)
)

logit_model <- glm(label ~ ., data = combined.data.cartlogit, family = "binomial")
pred.prob.cartlogit <- predict(logit_model, type = "response")
  
  label_vector.cartlogit <- combined.data.cartlogit$label
  
  prop.score.real.cartlogit <- pred.prob.cartlogit[label_vector.cartlogit == 0]
  prop.score.synt.cartlogit  <- pred.prob.cartlogit[label_vector.cartlogit == 1]

  ecdf.real.cartlogit <- ecdf(prop.score.real.cartlogit)
  ecdf.synth.cartlogit <- ecdf(prop.score.synt.cartlogit)

  all.scores.cartlogit <- sort(unique(c(prop.score.real.cartlogit, prop.score.synt.cartlogit)))

  specks.manual.cartlogit <- max(abs(ecdf.real.cartlogit(all.scores.cartlogit) - ecdf.synth.cartlogit(all.scores.cartlogit)))

#### KOLMOGOROV-SMIRNOV ####
ks.test(prop.score.real.cartlogit, prop.score.synt.cartlogit)
```


## SPECKS's distribution simulation
```{r}
specks.sim <- function(real, synt){
  ecdf.real <- ecdf(real)
  ecdf.synt <- ecdf(synt)
  
  all <- sort(unique(c(real, synt)))
  specks.value <- max(abs(ecdf.real(all) - ecdf.synt(all)))
  return(specks.value)
}

prop.scores.cartlogit <- c(prop.score.real.cartlogit, prop.score.synt.cartlogit)

n.real.cartlogit <- length(prop.score.real.cartlogit) 
n.synt.cartlogit <- length(prop.score.synt.cartlogit)
n.cartlogit1 <- c(n.real.cartlogit, n.synt.cartlogit)
N.cartlogit <- n.real.cartlogit+n.synt.cartlogit
nperms <- 9999

specks.perms.cartlogit <- replicate(nperms, {
  idx.cartlogit <- sample(1:N.cartlogit, n.real.cartlogit)
  real.cartlogit <- prop.scores.cartlogit[idx.cartlogit]
  synt.cartlogit <- prop.scores.cartlogit[-idx.cartlogit]
  
  specks.sim(real.cartlogit, synt.cartlogit)
})

specks.distribution.cartlogit <- ggplot(data.frame(Specks = specks.perms.cartlogit), aes(x=Specks)) + 
  geom_histogram(binwidth=0.01) +
  geom_vline(aes(xintercept = specks.manual.cartlogit, color = "Valor d'Specks"), 
             linetype = "dashed", size = 1) +
  scale_color_manual(name = "Leyenda", values = c("Valor d'Specks" = "red"))

comptador.cartlogit <- sum(specks.perms.cartlogit >= specks.manual.cartlogit)
pvalor.cartlogit <- (comptador.cartlogit+1)/(nperms+1)
pvalor.cartlogit

```

## Distribución de densidad de los propensity scores
```{r}
# Estimació suavitzada de la densitat a partir dels valors prop.score.real:
dens.prop.score.real.cartlogit= density(prop.score.real.cartlogit)
plot(dens.prop.score.real.cartlogit, col="green", main= "Estimació suavitzada scores", sub="(Gaussian Kernel)", ylim=c(0,10))
rang.x = seq(from = -0.1, to = 1, by = 0.1)
# La dibuixem superposada a les prop.score.synt, en vermell:
dens.prop.score.synt.cartlogit = density(prop.score.synt.cartlogit)
lines(dens.prop.score.synt.cartlogit, col="red")
abline(v = mean(prop.score.synt.cartlogit), col = "red", lwd = 2, lty = 2)
abline(v = mean(prop.score.real.cartlogit), col = "green", lwd = 2, lty = 2)
legend("topleft", legend=c("real", "synt"),  
       fill = c("green","red")) 
```

## Distribución acumulada de los propensity scores
```{r}
library(dplyr)

ecdf_real.cartlogit <- ecdf(prop.score.real.cartlogit)
ecdf_synt.cartlogit <- ecdf(prop.score.synt.cartlogit)

# Crear una cuadrícula de valores de propensity score a partir de los valores únicos (y ordenados)
grid_prop.cartlogit <- sort(unique(c(prop.score.real.cartlogit, prop.score.synt.cartlogit)))

# Calcular la probabilidad acumulada para cada valor de propensity score en la cuadrícula
prob_acumulada_ecdf_real.cartlogit <- ecdf_real.cartlogit(v = grid_prop.cartlogit)
prob_acumulada_ecdf_synt.cartlogit <- ecdf_synt.cartlogit(v = grid_prop.cartlogit)

# Unir los valores calculados en un dataframe
df_ecdf.cartlogit <- data.frame(
  propensity_score.cartlogit = grid_prop.cartlogit,
  ecdf_real.cartlogit = prob_acumulada_ecdf_real.cartlogit,
  ecdf_synt.cartlogit = prob_acumulada_ecdf_synt.cartlogit
) %>%
  pivot_longer(
    cols = c(ecdf_real.cartlogit, ecdf_synt.cartlogit),
    names_to = "data_type",
    values_to = "ecdf"
  )


# Graficar la función de distribución acumulada empírica de los propensity scores
grafico_ecdf.cartlogit <- ggplot(data = df_ecdf.cartlogit, 
                       aes(x = propensity_score.cartlogit, y = ecdf, color = data_type)) +
  geom_line(size = 0.5) +
  scale_color_manual(values = c("green", "red"), labels = c("Real", "Sintético")) +
  labs(
    title = "Distribución acumulada de Propensity Scores",
    subtitle = "Comparación entre datos reales y sintéticos",
    color = "Tipo",
    x = "Propensity Score",
    y = "Probabilidad acumulada"
  ) +
  theme_bw() +
  theme(legend.position = "bottom",
        plot.title = element_text(size = 12))

# Mostrar el gráfico
grafico_ecdf.cartlogit
```


# 3rd scenari: Generació amb model cart i càlcul de l'specks amb model de classificació CART pero amb un smoothing en la generació.
Resultat: El smoothing no ajuda, el SPECKS calculat mitjançant el mètode de classificació CART continua sent molt dolent.
```{r}
#### Data generation ####
my.seed <- 12345
set.seed(my.seed)
mu1 <- c(160, 50, 20, 7, 6, 8, 5, 8)
mu2 <- c(180, 65, 24, 5, 7, 8, 9, 6)

df1 <- normal.data.generation(n=250, mu=mu1)
df2 <- normal.data.generation(n=250, mu=mu2)

real.data.1 <- rbind(df1, df2)

sds.default.cart2 <- syn(real.data.1, method = "cart", seed = my.seed, m = 1, print.flag = FALSE, )
synt.data.cart2 <- sds.default.cart2$syn


#### SPECKS synthpop ####
utilityGen.cart2 <- utility.gen(sds.default.cart2, real.data.1, method = "cart", print.flag = FALSE, smoothing="spline")
specks.cart2.synthpop <- utilityGen.cart2$SPECKS


#### SPECKS manual ####
combined.data.cart2 <- rbind(
  cbind(real.data.1, label = 0), # Original data (label = 0)
  cbind(synt.data.cart2, label = 1) # Synthetic data (label = 1)
)

cart_model2 <- rpart(
  formula = label ~ .,             # label com a resposta, la resta com a predictors
  data = combined.data.cart2,
  method = "class",                # arbre de classificació
  control = rpart.control(mincriterion = 0, 
            minbucket = 5, 
            cp = 1e-3))

pred.prob.cart2 <- predict(cart_model2, type="prob")[,2]
  
  label_vector.cart2 <- combined.data.cart2$label
  
  prop.score.real.cart2  <- pred.prob.cart2[label_vector.cart2 == 0]
  prop.score.synt.cart2  <- pred.prob.cart2[label_vector.cart2 == 1]

  ecdf.real.cart2 <- ecdf(prop.score.real.cart2)
  ecdf.synth.cart2 <- ecdf(prop.score.synt.cart2)

  all.scores.cart2 <- sort(unique(c(prop.score.real.cart2, prop.score.synt.cart2)))

  specks.manual.cart2 <- max(abs(ecdf.real.cart2(all.scores.cart2) - ecdf.synth.cart2(all.scores.cart2)))

#### KOLMOGOROV-SMIRNOV ####
ks.test(prop.score.real.cart2, prop.score.synt.cart2)
```

## SPECKS's distribution simulation
```{r}
specks.sim <- function(real, synt){
  ecdf.real <- ecdf(real)
  ecdf.synt <- ecdf(synt)
  
  all <- sort(unique(c(real, synt)))
  specks.value <- max(abs(ecdf.real(all) - ecdf.synt(all)))
  return(specks.value)
}

prop.scores.cart2 <- c(prop.score.real.cart2, prop.score.synt.cart2)

n.real.cart2 <- length(prop.score.real.cart2) 
n.synt.cart2 <- length(prop.score.synt.cart2)
n.cart2 <- c(n.real.cart2, n.synt.cart2)
N.cart2 <- n.real.cart2+n.synt.cart2
nperms <- 9999

specks.perms.cart2 <- replicate(nperms, {
  idx.cart2 <- sample(1:N.cart2, n.real.cart2)
  real.cart2 <- prop.scores.cart2[idx.cart2]
  synt.cart2 <- prop.scores.cart2[-idx.cart2]
  
  specks.sim(real.cart2, synt.cart2)
})

specks.distribution.cart2 <- ggplot(data.frame(Specks = specks.perms.cart2), aes(x=Specks)) + 
  geom_histogram(binwidth=0.01) +
  geom_vline(aes(xintercept = specks.manual.cart2, color = "Valor d'Specks"), 
             linetype = "dashed", size = 1) +
  scale_color_manual(name = "Leyenda", values = c("Valor d'Specks" = "red"))

comptador.cart2 <- sum(specks.perms.cart2 >= specks.manual.cart2)
pvalor.cart2 <- (comptador.cart2+1)/(nperms+1)
pvalor.cart2

```


## Distribución de densidad de los propensity scores
```{r}
# Estimació suavitzada de la densitat a partir dels valors prop.score.real:
dens.prop.score.real.cart2= density(prop.score.real.cart2)
plot(dens.prop.score.real.cart2, col="green", main= "Estimació suavitzada scores", sub="(Gaussian Kernel)", ylim=c(0,10))
rang.x = seq(from = -0.1, to = 1, by = 0.1)
# La dibuixem superposada a les prop.score.synt, en vermell:
dens.prop.score.synt.cart2 = density(prop.score.synt.cart2)
lines(dens.prop.score.synt.cart2, col="red")
abline(v = mean(prop.score.synt.cart2), col = "red", lwd = 2, lty = 2)
abline(v = mean(prop.score.real.cart2), col = "green", lwd = 2, lty = 2)
legend("topleft", legend=c("real", "synt"),  
       fill = c("green","red")) 
```

## Distribución acumulada de los propensity scores
```{r}
library(dplyr)

ecdf_real.cart2 <- ecdf(prop.score.real.cart2)
ecdf_synt.cart2 <- ecdf(prop.score.synt.cart2)

# Crear una cuadrícula de valores de propensity score a partir de los valores únicos (y ordenados)
grid_prop.cart2 <- sort(unique(c(prop.score.real.cart2, prop.score.synt.cart2)))

# Calcular la probabilidad acumulada para cada valor de propensity score en la cuadrícula
prob_acumulada_ecdf_real.cart2 <- ecdf_real.cart2(v = grid_prop.cart2)
prob_acumulada_ecdf_synt.cart2 <- ecdf_synt.cart2(v = grid_prop.cart2)

# Unir los valores calculados en un dataframe
df_ecdf.cart2 <- data.frame(
  propensity_score.cart2 = grid_prop.cart2,
  ecdf_real.cart2 = prob_acumulada_ecdf_real.cart2,
  ecdf_synt.cart2 = prob_acumulada_ecdf_synt.cart2
) %>%
  pivot_longer(
    cols = c(ecdf_real.cart2, ecdf_synt.cart2),
    names_to = "data_type",
    values_to = "ecdf"
  )


# Graficar la función de distribución acumulada empírica de los propensity scores
grafico_ecdf.cart2 <- ggplot(data = df_ecdf.cart2, 
                       aes(x = propensity_score.cart2, y = ecdf, color = data_type)) +
  geom_line(size = 0.5) +
  scale_color_manual(values = c("green", "red"), labels = c("Real", "Sintético")) +
  labs(
    title = "Distribución acumulada de Propensity Scores",
    subtitle = "Comparación entre datos reales y sintéticos",
    color = "Tipo",
    x = "Propensity Score",
    y = "Probabilidad acumulada"
  ) +
  theme_bw() +
  theme(legend.position = "bottom",
        plot.title = element_text(size = 12))

# Mostrar el gráfico
grafico_ecdf.cart2
```
